{"componentChunkName":"component---src-templates-blog-post-js","path":"/429-googleapis/","result":{"data":{"site":{"siteMetadata":{"title":"SWE Journey"}},"markdownRemark":{"id":"6130cce6-da9f-59d2-bbab-3f6ed8b48607","excerpt":"Recently, I was working on syncing contracts in a user’s gmail inbox to our clm tool and when testing on my colleague’s account, we hit a 429 status code from…","html":"<p>Recently, I was working on syncing contracts in a user’s gmail inbox to our clm tool and when testing on my colleague’s account, we hit a 429 status code from Google servers and it was working fine on my own Google account. The corresponding message for 429 was <strong>Too Many Requests</strong> My first instinct was to look at the API quota and, to my surprise, peak usage per <strong>minute</strong> was not even 2%.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8ba5f494bda1718d67197e3c3e50fd84/0ad97/quota.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.26582278481011%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABJ0AAASdAHeZh94AAABuklEQVQ4y51U0XKbMBDk/z+pn9C+ZDJ96SQtSV2n2DXGBAmdkMR2ViBSMLGd3swNEtLs7Z60ypTx0MajKH7j4eERm80G2+0WeZ7jeDyC0ff9zZmFEKYJx977+P3fzAi03+8jG4IlRiluYfVvREARgbV2xvQjMmeSlxWuxZI9gwS6rnsDrOsabdvGRWMMdrsdlFLT5qW8qwzZQ55sURRotI79ZBGCpmTB0+kE59wq6xmgHkGapoE4F3vKJNuU7DGBOU59TjmivgHyJyuzD3Y8oGWK2GE9juUsU2uy61eih3UBlXJxHFb2kMwZ4KWwrkfZuKTs4g24iaF0YQRcZ/iu5BD7eQlw/cpQ8uyU35OcfmsJVyWfAa4l2TJ+HgT5XsaLvtwTZrbNlvKYS2d8flS4e9JnkrHi/ZmXne/R+TDNWzusfbp/xZfv7XjiAS4A4ob9q5LZVCsGvw4CJSGyLEqFb5s6Srz7UeNrXqEPDtJ5VLXGy59XaOFhhMmOEZCDk7J4fjmgOpbRflVVoSzLaDOGdx1Mq2FtF4sZ00a7EmxQPvMyK3gYsdNDwM3WymTJ9Irzm1wxrA3zlHyx/wKzFCcP/KGL6AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api usage!!!\"\n        title=\"api usage!!!\"\n        src=\"/static/8ba5f494bda1718d67197e3c3e50fd84/f058b/quota.png\"\n        srcset=\"/static/8ba5f494bda1718d67197e3c3e50fd84/c26ae/quota.png 158w,\n/static/8ba5f494bda1718d67197e3c3e50fd84/6bdcf/quota.png 315w,\n/static/8ba5f494bda1718d67197e3c3e50fd84/f058b/quota.png 630w,\n/static/8ba5f494bda1718d67197e3c3e50fd84/0ad97/quota.png 717w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>On further digging, we found <a href=\"https://developers.google.com/gmail/api/reference/quota\">this</a> per user per second limit of 250 units per second with each request given a unit like get - 5, send - 100 and so on. The justification behind this painful limit is that Google does not want the user’s servers to get overloaded and crash. This also avoids DoS attacks, I suppose, from malicious third parties. I would have put something similar in place if I had designed the system too.</p>\n<p>Ok. This is a fairly standard design decision by Google, and the solution must be available across the internet, right? <strong>No</strong>, The solution is fairly simple in a multi-threaded language.</p>\n<ol>\n<li>create 50 threads (50 * 5 = 250).</li>\n<li>make the request</li>\n<li>put the threads to sleep for 1 second</li>\n<li>Repeat till all resources are fetched</li>\n</ol>\n<p>Alas!, Node is single-threaded and relies on asynchronous programming for network requests. Node has no native API to control the number of unresolved promises or pause execution for a given time. First, we looked at some npm packages and <a href=\"https://www.npmjs.com/package/p-limit\">p-limit</a> was the only one with enough weekly downloads to be worthy of consideration, but it had no support for debouncing in terms of time, only concurrent promises.</p>\n<p>So, we ended up implementing the ideas in a blog post. I have given my understanding of his implementation and how we wrapped axios.get function in it. If you are interested, you can read more <a href=\"https://blog.thoughtspile.tech/2018/07/07/rate-limit-promises/\">here</a>.</p>\n<p>Since this is a complex problem with two paradigms (concurrency and time), let’s try to implement debounce for a single function first. setTimeout is an old API and relies on callbacks rather than promises. Not ideal!. (you can await or use then with promises only) So, let’s wrap it in a promise like below,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ok</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>ok<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We might need to change the time it awaits later or reuse it for another debounce with a different delay. So, let’s use a closure to make the delay configurable.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">resolveAfter</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">ms</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ok</span> <span class=\"token operator\">=></span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>ok<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>A new function call should now be made only after at least 1 second has passed since the previous function call. We have to make use of promise chaining to achieve this, as below.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">rateLimit1</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fn<span class=\"token punctuation\">,</span> msPerOp</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> wait <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// We use the queue tail in wait to start both the</span>\n    <span class=\"token comment\">// next operation and the next delay</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> wait<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    wait <span class=\"token operator\">=</span> wait<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">resolveAfter</span><span class=\"token punctuation\">(</span>msPerOp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> res\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, for the first call, the wait is resolved, so it calls fn without delay and has a promise attached that resolves after 1 second. Now, if a second call is made concurrently by ,say, <code class=\"language-text\">Promise.all</code>, the function call will only be made after the last promise in the wait object resolves (setTimeout). This is repeated for each call.</p>\n<p>Now we can wrap the promise and call with no worries, the operations\nare magically delayed.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> slowFetch <span class=\"token operator\">=</span> <span class=\"token function\">rateLimit1</span><span class=\"token punctuation\">(</span>axios<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>urls<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">u</span> <span class=\"token operator\">=></span> <span class=\"token function\">slowFetch</span><span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">raw</span> <span class=\"token operator\">=></span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span>raw<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">p</span> <span class=\"token operator\">=></span> p<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pages</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>pages<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now we just need to use this debounce for 50 function calls instead of one. One approach would be to create 50 promise objects in a queue and chain a single timeout to them. The issue is that even if one of them resolves before 1 s, then the 51st request would go through the empty slot before it times out.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">rateLimit</span><span class=\"token punctuation\">(</span><span class=\"token function\">concurrencyLimit</span><span class=\"token punctuation\">(</span>fetch<span class=\"token punctuation\">,</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span></code></pre></div>\n<p>So, we have to do the reverse and create 50 resolveAfter’s and put them in a circular queue so the 51st request waits for at least 1 second from the first request before executing.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">concurrencyLimit</span><span class=\"token punctuation\">(</span><span class=\"token function\">rateLimit</span><span class=\"token punctuation\">(</span>fetch<span class=\"token punctuation\">,</span> ms<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">N</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Below code implements this</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">rateLimit</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">fn</span><span class=\"token operator\">:</span> Function<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">delayMs</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span> maxConcurrent <span class=\"token operator\">=</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// A battery of 1-rate-limiters</span>\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> maxConcurrent <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n    <span class=\"token function\">rateLimit1</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> delayMs<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token comment\">// Circular queue cursor</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>a<span class=\"token operator\">:</span> any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// to enqueue, we move the cursor...</span>\n    i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> maxConcurrent <span class=\"token comment\">// and return the rate-limited operation.</span>\n    <span class=\"token keyword\">return</span> queue<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>a<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, we just need to replace <code class=\"language-text\">rateLimit1(axios.get, 1000)</code> with <code class=\"language-text\">rateLimit(axios.get, 1000, 49)</code>. I have left some leeway by using only 49 requests because a user opening Gmail app/website would also count as a request and shouldn’t result in 429.</p>\n<p>I hope you can use this idea to solve your rate limit problems in external services!!!!!!</p>","timeToRead":4,"frontmatter":{"title":"Rate limit api requests in nodejs","date":"October 28, 2022","description":"How to query external apis without hitting 429 rate limit in nodejs"}},"previous":{"fields":{"slug":"/toolbox/"},"frontmatter":{"title":"The developer toolbox"}},"next":null},"pageContext":{"id":"6130cce6-da9f-59d2-bbab-3f6ed8b48607","previousPostId":"d0f4ea87-453e-5648-82bb-41a8eb864221","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}